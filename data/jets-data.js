// Simplicity Jets Reference Data
// Verified against Haskell source code
// Last Updated: 2024

const JETS_DATA = {
    "core": {
        "Arithmetic Operations": [
            { name: "Add8", type: "(Word8, Word8) -> (Bit, Word8)", description: "Addition of two 8-bit words returning carry bit and sum" },
            { name: "Add16", type: "(Word16, Word16) -> (Bit, Word16)", description: "Addition of two 16-bit words returning carry bit and sum" },
            { name: "Add32", type: "(Word32, Word32) -> (Bit, Word32)", description: "Addition of two 32-bit words returning carry bit and sum" },
            { name: "Add64", type: "(Word64, Word64) -> (Bit, Word64)", description: "Addition of two 64-bit words returning carry bit and sum" },
            { name: "Decrement8", type: "Word8 -> (Bit, Word8)", description: "Decrement 8-bit word by 1 returning borrow bit and result" },
            { name: "Decrement16", type: "Word16 -> (Bit, Word16)", description: "Decrement 16-bit word by 1 returning borrow bit and result" },
            { name: "Decrement32", type: "Word32 -> (Bit, Word32)", description: "Decrement 32-bit word by 1 returning borrow bit and result" },
            { name: "Decrement64", type: "Word64 -> (Bit, Word64)", description: "Decrement 64-bit word by 1 returning borrow bit and result" },
            { name: "DivMod8", type: "(Word8, Word8) -> (Word8, Word8)", description: "Division and modulo of two 8-bit words returning quotient and remainder" },
            { name: "DivMod16", type: "(Word16, Word16) -> (Word16, Word16)", description: "Division and modulo of two 16-bit words returning quotient and remainder" },
            { name: "DivMod32", type: "(Word32, Word32) -> (Word32, Word32)", description: "Division and modulo of two 32-bit words returning quotient and remainder" },
            { name: "DivMod64", type: "(Word64, Word64) -> (Word64, Word64)", description: "Division and modulo of two 64-bit words returning quotient and remainder" },
            { name: "DivMod128_64", type: "(Word128, Word64) -> (Word64, Word64)", description: "Divide 128-bit word by 64-bit word returning quotient and remainder" },
            { name: "Divide8", type: "(Word8, Word8) -> Word8", description: "Division of two 8-bit words returning quotient" },
            { name: "Divide16", type: "(Word16, Word16) -> Word16", description: "Division of two 16-bit words returning quotient" },
            { name: "Divide32", type: "(Word32, Word32) -> Word32", description: "Division of two 32-bit words returning quotient" },
            { name: "Divide64", type: "(Word64, Word64) -> Word64", description: "Division of two 64-bit words returning quotient" },
            { name: "Divides8", type: "(Word8, Word8) -> Bit", description: "Check if first 8-bit word divides the second" },
            { name: "Divides16", type: "(Word16, Word16) -> Bit", description: "Check if first 16-bit word divides the second" },
            { name: "Divides32", type: "(Word32, Word32) -> Bit", description: "Check if first 32-bit word divides the second" },
            { name: "Divides64", type: "(Word64, Word64) -> Bit", description: "Check if first 64-bit word divides the second" },
            { name: "FeAdd", type: "(FE, FE) -> FE", description: "Add two secp256k1 field elements" },
            { name: "FeMultiply", type: "(FE, FE) -> FE", description: "Multiply two secp256k1 field elements" },
            { name: "FeMultiplyBeta", type: "FE -> FE", description: "Multiply secp256k1 field element by beta constant" },
            { name: "FeNegate", type: "FE -> FE", description: "Negate secp256k1 field element" },
            { name: "FullAdd8", type: "(Bit, (Word8, Word8)) -> (Bit, Word8)", description: "Full adder with carry input for 8-bit words" },
            { name: "FullAdd16", type: "(Bit, (Word16, Word16)) -> (Bit, Word16)", description: "Full adder with carry input for 16-bit words" },
            { name: "FullAdd32", type: "(Bit, (Word32, Word32)) -> (Bit, Word32)", description: "Full adder with carry input for 32-bit words" },
            { name: "FullAdd64", type: "(Bit, (Word64, Word64)) -> (Bit, Word64)", description: "Full adder with carry input for 64-bit words" },
            { name: "FullDecrement8", type: "(Bit, Word8) -> (Bit, Word8)", description: "Decrement with borrow input for 8-bit words" },
            { name: "FullDecrement16", type: "(Bit, Word16) -> (Bit, Word16)", description: "Decrement with borrow input for 16-bit words" },
            { name: "FullDecrement32", type: "(Bit, Word32) -> (Bit, Word32)", description: "Decrement with borrow input for 32-bit words" },
            { name: "FullDecrement64", type: "(Bit, Word64) -> (Bit, Word64)", description: "Decrement with borrow input for 64-bit words" },
            { name: "FullIncrement8", type: "(Bit, Word8) -> (Bit, Word8)", description: "Increment with carry input for 8-bit words" },
            { name: "FullIncrement16", type: "(Bit, Word16) -> (Bit, Word16)", description: "Increment with carry input for 16-bit words" },
            { name: "FullIncrement32", type: "(Bit, Word32) -> (Bit, Word32)", description: "Increment with carry input for 32-bit words" },
            { name: "FullIncrement64", type: "(Bit, Word64) -> (Bit, Word64)", description: "Increment with carry input for 64-bit words" },
            { name: "FullMultiply8", type: "((Word8, Word8), (Word8, Word8)) -> Word16", description: "Multiply two 8-bit words with two carry words producing 16-bit result" },
            { name: "FullMultiply16", type: "((Word16, Word16), (Word16, Word16)) -> Word32", description: "Multiply two 16-bit words with two carry words producing 32-bit result" },
            { name: "FullMultiply32", type: "((Word32, Word32), (Word32, Word32)) -> Word64", description: "Multiply two 32-bit words with two carry words producing 64-bit result" },
            { name: "FullMultiply64", type: "((Word64, Word64), (Word64, Word64)) -> Word128", description: "Multiply two 64-bit words with two carry words producing 128-bit result" },
            { name: "FullSubtract8", type: "(Bit, (Word8, Word8)) -> (Bit, Word8)", description: "Full subtractor with borrow input for 8-bit words" },
            { name: "FullSubtract16", type: "(Bit, (Word16, Word16)) -> (Bit, Word16)", description: "Full subtractor with borrow input for 16-bit words" },
            { name: "FullSubtract32", type: "(Bit, (Word32, Word32)) -> (Bit, Word32)", description: "Full subtractor with borrow input for 32-bit words" },
            { name: "FullSubtract64", type: "(Bit, (Word64, Word64)) -> (Bit, Word64)", description: "Full subtractor with borrow input for 64-bit words" },
            { name: "Increment8", type: "Word8 -> (Bit, Word8)", description: "Increment 8-bit word by 1 returning carry bit and result" },
            { name: "Increment16", type: "Word16 -> (Bit, Word16)", description: "Increment 16-bit word by 1 returning carry bit and result" },
            { name: "Increment32", type: "Word32 -> (Bit, Word32)", description: "Increment 32-bit word by 1 returning carry bit and result" },
            { name: "Increment64", type: "Word64 -> (Bit, Word64)", description: "Increment 64-bit word by 1 returning carry bit and result" },
            { name: "Max8", type: "(Word8, Word8) -> Word8", description: "Return maximum of two 8-bit words" },
            { name: "Max16", type: "(Word16, Word16) -> Word16", description: "Return maximum of two 16-bit words" },
            { name: "Max32", type: "(Word32, Word32) -> Word32", description: "Return maximum of two 32-bit words" },
            { name: "Max64", type: "(Word64, Word64) -> Word64", description: "Return maximum of two 64-bit words" },
            { name: "Median8", type: "(Word8, (Word8, Word8)) -> Word8", description: "Return median value of three 8-bit words" },
            { name: "Median16", type: "(Word16, (Word16, Word16)) -> Word16", description: "Return median value of three 16-bit words" },
            { name: "Median32", type: "(Word32, (Word32, Word32)) -> Word32", description: "Return median value of three 32-bit words" },
            { name: "Median64", type: "(Word64, (Word64, Word64)) -> Word64", description: "Return median value of three 64-bit words" },
            { name: "Min8", type: "(Word8, Word8) -> Word8", description: "Return minimum of two 8-bit words" },
            { name: "Min16", type: "(Word16, Word16) -> Word16", description: "Return minimum of two 16-bit words" },
            { name: "Min32", type: "(Word32, Word32) -> Word32", description: "Return minimum of two 32-bit words" },
            { name: "Min64", type: "(Word64, Word64) -> Word64", description: "Return minimum of two 64-bit words" },
            { name: "Modulo8", type: "(Word8, Word8) -> Word8", description: "Compute modulo (remainder) of first 8-bit word divided by second" },
            { name: "Modulo16", type: "(Word16, Word16) -> Word16", description: "Compute modulo (remainder) of first 16-bit word divided by second" },
            { name: "Modulo32", type: "(Word32, Word32) -> Word32", description: "Compute modulo (remainder) of first 32-bit word divided by second" },
            { name: "Modulo64", type: "(Word64, Word64) -> Word64", description: "Compute modulo (remainder) of first 64-bit word divided by second" },
            { name: "Multiply8", type: "(Word8, Word8) -> Word16", description: "Multiply two 8-bit words producing 16-bit result" },
            { name: "Multiply16", type: "(Word16, Word16) -> Word32", description: "Multiply two 16-bit words producing 32-bit result" },
            { name: "Multiply32", type: "(Word32, Word32) -> Word64", description: "Multiply two 32-bit words producing 64-bit result" },
            { name: "Multiply64", type: "(Word64, Word64) -> Word128", description: "Multiply two 64-bit words producing 128-bit result" },
            { name: "Negate8", type: "Word8 -> (Bit, Word8)", description: "Two's complement negation of 8-bit word" },
            { name: "Negate16", type: "Word16 -> (Bit, Word16)", description: "Two's complement negation of 16-bit word" },
            { name: "Negate32", type: "Word32 -> (Bit, Word32)", description: "Two's complement negation of 32-bit word" },
            { name: "Negate64", type: "Word64 -> (Bit, Word64)", description: "Two's complement negation of 64-bit word" },
            { name: "ScalarAdd", type: "(Scalar, Scalar) -> Scalar", description: "Add two secp256k1 scalars" },
            { name: "ScalarMultiply", type: "(Scalar, Scalar) -> Scalar", description: "Multiply two secp256k1 scalars" },
            { name: "ScalarMultiplyLambda", type: "Scalar -> Scalar", description: "Multiply secp256k1 scalar by lambda constant" },
            { name: "ScalarNegate", type: "Scalar -> Scalar", description: "Negate secp256k1 scalar" },
            { name: "Subtract8", type: "(Word8, Word8) -> (Bit, Word8)", description: "Subtraction of two 8-bit words returning borrow bit and difference" },
            { name: "Subtract16", type: "(Word16, Word16) -> (Bit, Word16)", description: "Subtraction of two 16-bit words returning borrow bit and difference" },
            { name: "Subtract32", type: "(Word32, Word32) -> (Bit, Word32)", description: "Subtraction of two 32-bit words returning borrow bit and difference" },
            { name: "Subtract64", type: "(Word64, Word64) -> (Bit, Word64)", description: "Subtraction of two 64-bit words returning borrow bit and difference" }
        ],
        "Bitwise Logic": [
            { name: "And1", type: "(Bit, Bit) -> Bit", description: "Bitwise AND of two bits" },
            { name: "And8", type: "(Word8, Word8) -> Word8", description: "Bitwise AND of two 8-bit words" },
            { name: "And16", type: "(Word16, Word16) -> Word16", description: "Bitwise AND of two 16-bit words" },
            { name: "And32", type: "(Word32, Word32) -> Word32", description: "Bitwise AND of two 32-bit words" },
            { name: "And64", type: "(Word64, Word64) -> Word64", description: "Bitwise AND of two 64-bit words" },
            { name: "Ch1", type: "(Bit, (Bit, Bit)) -> Bit", description: "Bitwise choice: if first bit is 1 choose second, else choose third" },
            { name: "Ch8", type: "(Word8, (Word8, Word8)) -> Word8", description: "Bitwise choice for 8-bit words" },
            { name: "Ch16", type: "(Word16, (Word16, Word16)) -> Word16", description: "Bitwise choice for 16-bit words" },
            { name: "Ch32", type: "(Word32, (Word32, Word32)) -> Word32", description: "Bitwise choice for 32-bit words" },
            { name: "Ch64", type: "(Word64, (Word64, Word64)) -> Word64", description: "Bitwise choice for 64-bit words" },
            { name: "Complement1", type: "Bit -> Bit", description: "Bitwise NOT of bit" },
            { name: "Complement8", type: "Word8 -> Word8", description: "Bitwise NOT (complement) of 8-bit word" },
            { name: "Complement16", type: "Word16 -> Word16", description: "Bitwise NOT (complement) of 16-bit word" },
            { name: "Complement32", type: "Word32 -> Word32", description: "Bitwise NOT (complement) of 32-bit word" },
            { name: "Complement64", type: "Word64 -> Word64", description: "Bitwise NOT (complement) of 64-bit word" },
            { name: "Maj1", type: "(Bit, (Bit, Bit)) -> Bit", description: "Majority function: returns majority of three bits" },
            { name: "Maj8", type: "(Word8, (Word8, Word8)) -> Word8", description: "Majority function for 8-bit words" },
            { name: "Maj16", type: "(Word16, (Word16, Word16)) -> Word16", description: "Majority function for 16-bit words" },
            { name: "Maj32", type: "(Word32, (Word32, Word32)) -> Word32", description: "Majority function for 32-bit words" },
            { name: "Maj64", type: "(Word64, (Word64, Word64)) -> Word64", description: "Majority function for 64-bit words" },
            { name: "Or1", type: "(Bit, Bit) -> Bit", description: "Bitwise OR of two bits" },
            { name: "Or8", type: "(Word8, Word8) -> Word8", description: "Bitwise OR of two 8-bit words" },
            { name: "Or16", type: "(Word16, Word16) -> Word16", description: "Bitwise OR of two 16-bit words" },
            { name: "Or32", type: "(Word32, Word32) -> Word32", description: "Bitwise OR of two 32-bit words" },
            { name: "Or64", type: "(Word64, Word64) -> Word64", description: "Bitwise OR of two 64-bit words" },
            { name: "Xor1", type: "(Bit, Bit) -> Bit", description: "Bitwise XOR of two bits" },
            { name: "Xor8", type: "(Word8, Word8) -> Word8", description: "Bitwise XOR of two 8-bit words" },
            { name: "Xor16", type: "(Word16, Word16) -> Word16", description: "Bitwise XOR of two 16-bit words" },
            { name: "Xor32", type: "(Word32, Word32) -> Word32", description: "Bitwise XOR of two 32-bit words" },
            { name: "Xor64", type: "(Word64, Word64) -> Word64", description: "Bitwise XOR of two 64-bit words" },
            { name: "XorXor1", type: "(Bit, (Bit, Bit)) -> Bit", description: "XOR of three bits" },
            { name: "XorXor8", type: "(Word8, (Word8, Word8)) -> Word8", description: "XOR of three 8-bit words" },
            { name: "XorXor16", type: "(Word16, (Word16, Word16)) -> Word16", description: "XOR of three 16-bit words" },
            { name: "XorXor32", type: "(Word32, (Word32, Word32)) -> Word32", description: "XOR of three 32-bit words" },
            { name: "XorXor64", type: "(Word64, (Word64, Word64)) -> Word64", description: "XOR of three 64-bit words" }
        ],
        "Comparison & Testing": [
            { name: "All8", type: "Word8 -> Bit", description: "Test if all bits are set in 8-bit word" },
            { name: "All16", type: "Word16 -> Bit", description: "Test if all bits are set in 16-bit word" },
            { name: "All32", type: "Word32 -> Bit", description: "Test if all bits are set in 32-bit word" },
            { name: "All64", type: "Word64 -> Bit", description: "Test if all bits are set in 64-bit word" },
            { name: "Eq1", type: "(Bit, Bit) -> Bit", description: "Test equality of two bits" },
            { name: "Eq8", type: "(Word8, Word8) -> Bit", description: "Test equality of two 8-bit words" },
            { name: "Eq16", type: "(Word16, Word16) -> Bit", description: "Test equality of two 16-bit words" },
            { name: "Eq32", type: "(Word32, Word32) -> Bit", description: "Test equality of two 32-bit words" },
            { name: "Eq64", type: "(Word64, Word64) -> Bit", description: "Test equality of two 64-bit words" },
            { name: "Eq256", type: "(Word256, Word256) -> Bit", description: "Test equality of two 256-bit words" },
            { name: "FeIsZero", type: "FE -> Bit", description: "Test if secp256k1 field element is zero" },
            { name: "GejEquiv", type: "(GEJ, GEJ) -> Bit", description: "Test equivalence of two Jacobian points" },
            { name: "GejGeEquiv", type: "(GEJ, GE) -> Bit", description: "Test equivalence of Jacobian and affine points" },
            { name: "GejXEquiv", type: "(FE, GEJ) -> Bit", description: "Test if Jacobian point has given x-coordinate" },
            { name: "IsOne8", type: "Word8 -> Bit", description: "Test if 8-bit word is one" },
            { name: "IsOne16", type: "Word16 -> Bit", description: "Test if 16-bit word is one" },
            { name: "IsOne32", type: "Word32 -> Bit", description: "Test if 32-bit word is one" },
            { name: "IsOne64", type: "Word64 -> Bit", description: "Test if 64-bit word is one" },
            { name: "IsZero8", type: "Word8 -> Bit", description: "Test if 8-bit word is zero" },
            { name: "IsZero16", type: "Word16 -> Bit", description: "Test if 16-bit word is zero" },
            { name: "IsZero32", type: "Word32 -> Bit", description: "Test if 32-bit word is zero" },
            { name: "IsZero64", type: "Word64 -> Bit", description: "Test if 64-bit word is zero" },
            { name: "Le8", type: "(Word8, Word8) -> Bit", description: "Test if first 8-bit word is less than or equal to second" },
            { name: "Le16", type: "(Word16, Word16) -> Bit", description: "Test if first 16-bit word is less than or equal to second" },
            { name: "Le32", type: "(Word32, Word32) -> Bit", description: "Test if first 32-bit word is less than or equal to second" },
            { name: "Le64", type: "(Word64, Word64) -> Bit", description: "Test if first 64-bit word is less than or equal to second" },
            { name: "Lt8", type: "(Word8, Word8) -> Bit", description: "Test if first 8-bit word is less than second" },
            { name: "Lt16", type: "(Word16, Word16) -> Bit", description: "Test if first 16-bit word is less than second" },
            { name: "Lt32", type: "(Word32, Word32) -> Bit", description: "Test if first 32-bit word is less than second" },
            { name: "Lt64", type: "(Word64, Word64) -> Bit", description: "Test if first 64-bit word is less than second" },
            { name: "ScalarIsZero", type: "Scalar -> Bit", description: "Test if secp256k1 scalar is zero" },
            { name: "Some8", type: "Word8 -> Bit", description: "Test if any bit is set in 8-bit word" },
            { name: "Some16", type: "Word16 -> Bit", description: "Test if any bit is set in 16-bit word" },
            { name: "Some32", type: "Word32 -> Bit", description: "Test if any bit is set in 32-bit word" },
            { name: "Some64", type: "Word64 -> Bit", description: "Test if any bit is set in 64-bit word" }
        ],
        "Shift & Rotate": [
            { name: "LeftRotate8", type: "(Word4, Word8) -> Word8", description: "Left rotate (circular shift) 8-bit word" },
            { name: "LeftRotate16", type: "(Word4, Word16) -> Word16", description: "Left rotate (circular shift) 16-bit word" },
            { name: "LeftRotate32", type: "(Word8, Word32) -> Word32", description: "Left rotate (circular shift) 32-bit word" },
            { name: "LeftRotate64", type: "(Word8, Word64) -> Word64", description: "Left rotate (circular shift) 64-bit word" },
            { name: "LeftShift8", type: "(Word4, Word8) -> Word8", description: "Left shift 8-bit word by specified amount" },
            { name: "LeftShift16", type: "(Word4, Word16) -> Word16", description: "Left shift 16-bit word by specified amount" },
            { name: "LeftShift32", type: "(Word8, Word32) -> Word32", description: "Left shift 32-bit word by specified amount" },
            { name: "LeftShift64", type: "(Word8, Word64) -> Word64", description: "Left shift 64-bit word by specified amount" },
            { name: "LeftShiftWith8", type: "(Bit, (Word4, Word8)) -> Word8", description: "Left shift 8-bit word filling with specified bit" },
            { name: "LeftShiftWith16", type: "(Bit, (Word4, Word16)) -> Word16", description: "Left shift 16-bit word filling with specified bit" },
            { name: "LeftShiftWith32", type: "(Bit, (Word8, Word32)) -> Word32", description: "Left shift 32-bit word filling with specified bit" },
            { name: "LeftShiftWith64", type: "(Bit, (Word8, Word64)) -> Word64", description: "Left shift 64-bit word filling with specified bit" },
            { name: "RightRotate8", type: "(Word4, Word8) -> Word8", description: "Right rotate (circular shift) 8-bit word" },
            { name: "RightRotate16", type: "(Word4, Word16) -> Word16", description: "Right rotate (circular shift) 16-bit word" },
            { name: "RightRotate32", type: "(Word8, Word32) -> Word32", description: "Right rotate (circular shift) 32-bit word" },
            { name: "RightRotate64", type: "(Word8, Word64) -> Word64", description: "Right rotate (circular shift) 64-bit word" },
            { name: "RightShift8", type: "(Word4, Word8) -> Word8", description: "Right shift 8-bit word by specified amount" },
            { name: "RightShift16", type: "(Word4, Word16) -> Word16", description: "Right shift 16-bit word by specified amount" },
            { name: "RightShift32", type: "(Word8, Word32) -> Word32", description: "Right shift 32-bit word by specified amount" },
            { name: "RightShift64", type: "(Word8, Word64) -> Word64", description: "Right shift 64-bit word by specified amount" },
            { name: "RightShiftWith8", type: "(Bit, (Word4, Word8)) -> Word8", description: "Right shift 8-bit word filling with specified bit" },
            { name: "RightShiftWith16", type: "(Bit, (Word4, Word16)) -> Word16", description: "Right shift 16-bit word filling with specified bit" },
            { name: "RightShiftWith32", type: "(Bit, (Word8, Word32)) -> Word32", description: "Right shift 32-bit word filling with specified bit" },
            { name: "RightShiftWith64", type: "(Bit, (Word8, Word64)) -> Word64", description: "Right shift 64-bit word filling with specified bit" }
        ],
        "Constants": [
            { name: "High1", type: "() -> Bit", description: "Constant bit with value 1" },
            { name: "High8", type: "() -> Word8", description: "Constant 8-bit word with all bits set to 1" },
            { name: "High16", type: "() -> Word16", description: "Constant 16-bit word with all bits set to 1" },
            { name: "High32", type: "() -> Word32", description: "Constant 32-bit word with all bits set to 1" },
            { name: "High64", type: "() -> Word64", description: "Constant 64-bit word with all bits set to 1" },
            { name: "Low1", type: "() -> Bit", description: "Constant bit with value 0" },
            { name: "Low8", type: "() -> Word8", description: "Constant 8-bit word with all bits set to 0" },
            { name: "Low16", type: "() -> Word16", description: "Constant 16-bit word with all bits set to 0" },
            { name: "Low32", type: "() -> Word32", description: "Constant 32-bit word with all bits set to 0" },
            { name: "Low64", type: "() -> Word64", description: "Constant 64-bit word with all bits set to 0" },
            { name: "One8", type: "() -> Word8", description: "Constant 8-bit word with value 1" },
            { name: "One16", type: "() -> Word16", description: "Constant 16-bit word with value 1" },
            { name: "One32", type: "() -> Word32", description: "Constant 32-bit word with value 1" },
            { name: "One64", type: "() -> Word64", description: "Constant 64-bit word with value 1" }
        ],
        "Secp256k1 Operations": [
            { name: "Decompress", type: "Point -> Maybe GE", description: "Decompress secp256k1 public key from x-coordinate" },
            { name: "FeInvert", type: "FE -> FE", description: "Compute multiplicative inverse of secp256k1 field element" },
            { name: "FeIsOdd", type: "FE -> Bit", description: "Test if secp256k1 field element is odd" },
            { name: "FeNormalize", type: "FE -> FE", description: "Normalize secp256k1 field element to canonical form" },
            { name: "FeSquare", type: "FE -> FE", description: "Square secp256k1 field element" },
            { name: "FeSquareRoot", type: "FE -> Maybe FE", description: "Compute square root of secp256k1 field element if it exists" },
            { name: "Generate", type: "Scalar -> GEJ", description: "Generate secp256k1 public key from scalar (scalar multiplication by generator point)" },
            { name: "GeIsOnCurve", type: "GE -> Bit", description: "Test if affine point is on the secp256k1 curve" },
            { name: "GeNegate", type: "GE -> GE", description: "Negate affine elliptic curve point" },
            { name: "GejAdd", type: "(GEJ, GEJ) -> GEJ", description: "Add two Jacobian elliptic curve points" },
            { name: "GejDouble", type: "GEJ -> GEJ", description: "Double Jacobian elliptic curve point" },
            { name: "GejGeAdd", type: "(GEJ, GE) -> GEJ", description: "Add Jacobian point to affine point" },
            { name: "GejGeAddEx", type: "(GEJ, GE) -> (FE, GEJ)", description: "Add Jacobian point to affine point with extra output" },
            { name: "GejInfinity", type: "() -> GEJ", description: "Create point at infinity in Jacobian coordinates" },
            { name: "GejIsInfinity", type: "GEJ -> Bit", description: "Test if Jacobian point is at infinity" },
            { name: "GejIsOnCurve", type: "GEJ -> Bit", description: "Test if Jacobian point is on the curve" },
            { name: "GejNegate", type: "GEJ -> GEJ", description: "Negate Jacobian elliptic curve point" },
            { name: "GejNormalize", type: "GEJ -> Maybe GE", description: "Normalize Jacobian point to affine coordinates" },
            { name: "GejRescale", type: "(GEJ, FE) -> GEJ", description: "Rescale Jacobian point by field element" },
            { name: "GejYIsOdd", type: "GEJ -> Bit", description: "Test if y-coordinate of Jacobian point is odd" },
            { name: "HashToCurve", type: "Word256 -> GE", description: "Hash arbitrary data to curve point" },
            { name: "LinearCombination1", type: "((Scalar, GEJ), Scalar) -> GEJ", description: "Compute s1*P1 + s2*G where s1,s2 are scalars, P1 is a point, G is generator" },
            { name: "LinearVerify1", type: "(((Scalar, GE), Scalar), GE) -> ()", description: "Verify that s1*P1 + s2*P2 = point at infinity (linear combination check)" },
            { name: "PointVerify1", type: "(((Scalar, Point), Scalar), Point) -> ()", description: "Verify Schnorr signature equation using linear combination" },
            { name: "Scale", type: "(Scalar, GEJ) -> GEJ", description: "Scalar multiplication of curve point" },
            { name: "ScalarInvert", type: "Scalar -> Scalar", description: "Compute multiplicative inverse of secp256k1 scalar" },
            { name: "ScalarNormalize", type: "Scalar -> Scalar", description: "Normalize secp256k1 scalar to canonical form" },
            { name: "ScalarSquare", type: "Scalar -> Scalar", description: "Square secp256k1 scalar" },
            { name: "Swu", type: "FE -> GE", description: "Shallue-van de Woestijne encoding to curve point" }
        ],
        "Signatures & Verification": [
            { name: "Bip0340Verify", type: "((PubKey, Word256), Sig) -> ()", description: "Verify BIP-340 Schnorr signature" },
            { name: "CheckSigVerify", type: "((PubKey, Word512), Sig) -> ()", description: "Verify Schnorr signature and fail if invalid" },
            { name: "Verify", type: "Bit -> ()", description: "Assert that input bit is true (fail if false)" }
        ],
        "SHA256 Hashing": [
            { name: "Sha256Block", type: "(Hash256, Block512) -> Hash256", description: "Process single 512-bit block through SHA256 compression function" },
            { name: "Sha256Ctx8Add1", type: "(Ctx8, Bit) -> Ctx8", description: "Add 1-bit data to SHA256 context" },
            { name: "Sha256Ctx8Add2", type: "(Ctx8, Word2) -> Ctx8", description: "Add 2-bit data to SHA256 context" },
            { name: "Sha256Ctx8Add4", type: "(Ctx8, Word4) -> Ctx8", description: "Add 4-bit data to SHA256 context" },
            { name: "Sha256Ctx8Add8", type: "(Ctx8, Word8) -> Ctx8", description: "Add 8-bit data to SHA256 context" },
            { name: "Sha256Ctx8Add16", type: "(Ctx8, Word16) -> Ctx8", description: "Add 16-bit data to SHA256 context" },
            { name: "Sha256Ctx8Add32", type: "(Ctx8, Word32) -> Ctx8", description: "Add 32-bit data to SHA256 context" },
            { name: "Sha256Ctx8Add64", type: "(Ctx8, Word64) -> Ctx8", description: "Add 64-bit data to SHA256 context" },
            { name: "Sha256Ctx8Add128", type: "(Ctx8, Word128) -> Ctx8", description: "Add 128-bit data to SHA256 context" },
            { name: "Sha256Ctx8Add256", type: "(Ctx8, Word256) -> Ctx8", description: "Add 256-bit data to SHA256 context" },
            { name: "Sha256Ctx8Add512", type: "(Ctx8, Word512) -> Ctx8", description: "Add 512-bit data to SHA256 context" },
            { name: "Sha256Ctx8AddBuffer511", type: "(Ctx8, Buffer511) -> Ctx8", description: "Add buffer up to 511 bytes to SHA256 context" },
            { name: "Sha256Ctx8Finalize", type: "Ctx8 -> Hash256", description: "Finalize SHA256 hash computation from context returning hash digest" },
            { name: "Sha256Ctx8Init", type: "() -> Ctx8", description: "Initialize SHA256 context to initial state" },
            { name: "Sha256Iv", type: "() -> Hash256", description: "Get SHA256 initial values" }
        ],
        "Time Locks": [
            { name: "ParseLock", type: "Word32 -> Either Word32 Word32", description: "Parse lock time from transaction data" },
            { name: "ParseSequence", type: "Word32 -> Maybe (Either Word16 Word16)", description: "Parse sequence number from input data" }
        ],
        "Taproot": [
            { name: "TapdataInit", type: "() -> Ctx8", description: "Initialize taproot data structure" }
        ]
    },
    "elements": {
        "Transaction Data": [
            { name: "CurrentAmount", type: "() -> (ConfWord256, ConfWord64)", description: "Get confidential amount (value blinding, amount) of current input" },
            { name: "CurrentAsset", type: "() -> ConfWord256", description: "Get confidential asset ID of current input" },
            { name: "CurrentIndex", type: "() -> Word32", description: "Get index of current input being validated" },
            { name: "CurrentPegin", type: "() -> Maybe Word256", description: "Get peg-in proof for current input (if applicable)" },
            { name: "CurrentPrevOutpoint", type: "() -> (Word256, Word32)", description: "Get previous outpoint (txid, vout) of current input" },
            { name: "CurrentReissuanceBlinding", type: "() -> Word256", description: "Get reissuance blinding nonce of current input" },
            { name: "CurrentReissuanceEntropy", type: "() -> Word256", description: "Get reissuance entropy of current input" },
            { name: "CurrentSequence", type: "() -> Word32", description: "Get sequence number of current input" },
            { name: "NumInputs", type: "() -> Word32", description: "Get number of transaction inputs" },
            { name: "NumOutputs", type: "() -> Word32", description: "Get number of transaction outputs" },
            { name: "TotalFee", type: "Word256 -> Word64", description: "Calculate total fee for specified asset" },
            { name: "TransactionId", type: "() -> Word256", description: "Get current transaction ID" },
            { name: "Version", type: "() -> Word32", description: "Get transaction version number" }
        ],
        "Transaction Inputs": [
            { name: "InputAmount", type: "Word32 -> Maybe (ConfWord256, ConfWord64)", description: "Get confidential amount of specified input by index" },
            { name: "InputAmountsHash", type: "() -> Word256", description: "Compute hash of all input amounts" },
            { name: "InputAnnexHash", type: "Word32 -> Maybe Word256", description: "Get annex hash of specified input by index" },
            { name: "InputAnnexesHash", type: "() -> Word256", description: "Compute hash of all input annexes" },
            { name: "InputAsset", type: "Word32 -> Maybe ConfWord256", description: "Get confidential asset ID of specified input by index" },
            { name: "InputHash", type: "Word32 -> Word256", description: "Compute hash of individual input" },
            { name: "InputOutpointsHash", type: "() -> Word256", description: "Compute hash of all input outpoints" },
            { name: "InputPegin", type: "Word32 -> Maybe Word256", description: "Get peg-in proof of specified input by index" },
            { name: "InputPrevOutpoint", type: "Word32 -> Maybe (Word256, Word32)", description: "Get previous outpoint of specified input by index" },
            { name: "InputScriptHash", type: "Word32 -> Maybe Word256", description: "Get script hash of specified input by index" },
            { name: "InputScriptsHash", type: "() -> Word256", description: "Compute hash of all input scripts" },
            { name: "InputScriptSigHash", type: "Word32 -> Maybe Word256", description: "Get scriptSig hash of specified input by index" },
            { name: "InputScriptSigsHash", type: "() -> Word256", description: "Compute hash of all input scriptSigs" },
            { name: "InputSequence", type: "Word32 -> Maybe Word32", description: "Get sequence number of specified input by index" },
            { name: "InputSequencesHash", type: "() -> Word256", description: "Compute hash of all input sequences" },
            { name: "InputUtxoHash", type: "Word32 -> Word256", description: "Compute hash of UTXO at specified input" },
            { name: "InputUtxosHash", type: "() -> Word256", description: "Compute hash of all input UTXOs" },
            { name: "InputsHash", type: "() -> Word256", description: "Compute hash of all transaction inputs" }
        ],
        "Transaction Outputs": [
            { name: "OutputAmount", type: "Word32 -> Maybe (ConfWord256, ConfWord64)", description: "Get confidential amount of specified output by index" },
            { name: "OutputAmountsHash", type: "() -> Word256", description: "Compute hash of all output amounts" },
            { name: "OutputAsset", type: "Word32 -> Maybe ConfWord256", description: "Get confidential asset ID of specified output by index" },
            { name: "OutputHash", type: "Word32 -> Word256", description: "Compute hash of individual output" },
            { name: "OutputIsFee", type: "Word32 -> Maybe Bit", description: "Test if specified output is a fee output" },
            { name: "OutputNonce", type: "Word32 -> Maybe ConfWord256", description: "Get confidential nonce of specified output by index" },
            { name: "OutputNoncesHash", type: "() -> Word256", description: "Compute hash of all output nonces" },
            { name: "OutputNullDatum", type: "Word32 -> Maybe ()", description: "Get null datum field of specified output by index" },
            { name: "OutputRangeProof", type: "Word32 -> Maybe Word256", description: "Get value range proof hash of specified output by index" },
            { name: "OutputRangeProofsHash", type: "() -> Word256", description: "Compute hash of all output range proofs" },
            { name: "OutputScriptHash", type: "Word32 -> Maybe Word256", description: "Get script hash of specified output by index" },
            { name: "OutputScriptsHash", type: "() -> Word256", description: "Compute hash of all output scripts" },
            { name: "OutputSurjectionProof", type: "Word32 -> Maybe Word256", description: "Get asset surjection proof hash of specified output by index" },
            { name: "OutputSurjectionProofsHash", type: "() -> Word256", description: "Compute hash of all output surjection proofs" },
            { name: "OutputsHash", type: "() -> Word256", description: "Compute hash of all transaction outputs" }
        ],
        "Issuance": [
            { name: "CalculateAsset", type: "Word256 -> Word256", description: "Calculate asset ID from entropy" },
            { name: "CalculateConfidentialToken", type: "Word256 -> Word256", description: "Calculate confidential reissuance token ID" },
            { name: "CalculateExplicitToken", type: "Word256 -> Word256", description: "Calculate explicit reissuance token ID" },
            { name: "CalculateIssuanceEntropy", type: "((Word256, Word32), Word256) -> Word256", description: "Calculate issuance entropy from previous outpoint and contract hash" },
            { name: "CurrentIssuanceAssetAmount", type: "() -> (ConfWord256, ConfWord64)", description: "Get issuance asset amount of current input" },
            { name: "CurrentIssuanceAssetProof", type: "() -> Word256", description: "Get issuance asset range proof of current input" },
            { name: "CurrentIssuanceTokenAmount", type: "() -> (ConfWord256, ConfWord64)", description: "Get issuance token amount of current input" },
            { name: "CurrentIssuanceTokenProof", type: "() -> Word256", description: "Get issuance token range proof of current input" },
            { name: "CurrentNewIssuanceContract", type: "() -> Word256", description: "Get new issuance contract hash of current input" },
            { name: "IssuanceAsset", type: "Word32 -> Maybe Word256", description: "Get asset ID for specified issuance by input index" },
            { name: "IssuanceAssetAmount", type: "Word32 -> Maybe (ConfWord256, ConfWord64)", description: "Get asset amount for specified issuance by input index" },
            { name: "IssuanceAssetAmountsHash", type: "() -> Word256", description: "Compute hash of all issuance asset amounts" },
            { name: "IssuanceAssetProof", type: "Word32 -> Maybe Word256", description: "Get asset amount range proof for specified issuance by input index" },
            { name: "IssuanceBlindingEntropyHash", type: "() -> Word256", description: "Compute hash of all issuance blinding entropies" },
            { name: "IssuanceEntropy", type: "Word32 -> Maybe Word256", description: "Get issuance entropy for specified issuance by input index" },
            { name: "IssuanceHash", type: "Word32 -> Word256", description: "Compute hash of individual issuance" },
            { name: "IssuanceRangeProofsHash", type: "() -> Word256", description: "Compute hash of all issuance range proofs" },
            { name: "IssuanceToken", type: "Word32 -> Maybe Word256", description: "Get reissuance token ID for specified issuance by input index" },
            { name: "IssuanceTokenAmount", type: "Word32 -> Maybe (ConfWord256, ConfWord64)", description: "Get token amount for specified issuance by input index" },
            { name: "IssuanceTokenAmountsHash", type: "() -> Word256", description: "Compute hash of all issuance token amounts" },
            { name: "IssuanceTokenProof", type: "Word32 -> Maybe Word256", description: "Get token amount range proof for specified issuance by input index" },
            { name: "IssuancesHash", type: "() -> Word256", description: "Compute hash of all issuances" },
            { name: "LbtcAsset", type: "() -> Word256", description: "Get the L-BTC (Liquid Bitcoin) asset ID constant" }
        ],
        "Time Locks": [
            { name: "CheckLockDistance", type: "Word16 -> ()", description: "Verify that input's sequence uses block distance and matches" },
            { name: "CheckLockDuration", type: "Word16 -> ()", description: "Verify that input's sequence uses time duration and matches" },
            { name: "CheckLockHeight", type: "Word32 -> ()", description: "Verify that input's locktime uses block height and matches" },
            { name: "CheckLockTime", type: "Word32 -> ()", description: "Verify that input's locktime uses block time and matches" },
            { name: "LockTime", type: "() -> Word32", description: "Get transaction lock time" },
            { name: "TxIsFinal", type: "() -> Bit", description: "Test if transaction is final (all inputs have max sequence)" },
            { name: "TxLockDistance", type: "() -> Word16", description: "Get transaction lock distance from sequence number" },
            { name: "TxLockDuration", type: "() -> Word16", description: "Get transaction lock duration from sequence number" },
            { name: "TxLockHeight", type: "() -> Word32", description: "Get transaction lock time as block height (if applicable)" },
            { name: "TxLockTime", type: "() -> Word32", description: "Get transaction lock time as Unix timestamp (if applicable)" }
        ],
        "Taproot": [
            { name: "AnnexHash", type: "Word256 -> Word256", description: "Compute hash of annex data" },
            { name: "BuildTapbranch", type: "(Word256, Word256) -> Word256", description: "Compute taproot branch hash from two child hashes" },
            { name: "BuildTapleafSimplicity", type: "Word256 -> Word256", description: "Compute taproot leaf hash for Simplicity script" },
            { name: "BuildTaptweak", type: "(PubKey, Word256) -> Word256", description: "Compute taproot tweak from internal key and merkle root" },
            { name: "CurrentAnnexHash", type: "() -> Maybe Word256", description: "Get annex hash of current input" },
            { name: "CurrentScriptHash", type: "() -> Word256", description: "Get script hash of current input being validated" },
            { name: "InternalKey", type: "() -> PubKey", description: "Get taproot internal public key" },
            { name: "ScriptCMR", type: "() -> Word256", description: "Get commitment Merkle root of current script" },
            { name: "TapEnvHash", type: "() -> Word256", description: "Compute taproot environment hash" },
            { name: "TapleafHash", type: "() -> Word256", description: "Compute hash of taproot leaf" },
            { name: "TapleafVersion", type: "() -> Word8", description: "Get version byte of current taproot script leaf" },
            { name: "Tappath", type: "() -> Path", description: "Get taproot script path" },
            { name: "TappathHash", type: "() -> Word256", description: "Compute hash of taproot path" }
        ],
        "Signatures": [
            { name: "CurrentScriptSigHash", type: "() -> Word256", description: "Get script signature hash for current input" },
            { name: "SigAllHash", type: "() -> Word256", description: "Compute SIGHASH_ALL message hash" }
        ],
        "Network Constants": [
            { name: "GenesisBlockHash", type: "() -> Word256", description: "Get genesis block hash for the blockchain" }
        ]
    },
    "bitcoin": {
        "Transaction Data": [
            { name: "CurrentIndex", type: "() -> Word32", description: "Get index of current input being validated" },
            { name: "CurrentPrevOutpoint", type: "() -> (Word256, Word32)", description: "Get previous outpoint (txid, vout) of current input" },
            { name: "CurrentSequence", type: "() -> Word32", description: "Get sequence number of current input" },
            { name: "CurrentValue", type: "() -> Word64", description: "Get value of current input being validated" },
            { name: "NumInputs", type: "() -> Word32", description: "Get number of transaction inputs" },
            { name: "NumOutputs", type: "() -> Word32", description: "Get number of transaction outputs" },
            { name: "TotalInputValue", type: "() -> Word64", description: "Calculate total value of all transaction inputs" },
            { name: "TotalOutputValue", type: "() -> Word64", description: "Calculate total value of all transaction outputs" },
            { name: "Version", type: "() -> Word32", description: "Get transaction version number" }
        ],
        "Transaction Inputs": [
            { name: "InputAnnexHash", type: "Word32 -> Maybe Word256", description: "Get annex hash of specified input by index" },
            { name: "InputPrevOutpoint", type: "Word32 -> Maybe (Word256, Word32)", description: "Get previous outpoint of specified input by index" },
            { name: "InputSequence", type: "Word32 -> Maybe Word32", description: "Get sequence number of specified input by index" },
            { name: "InputValue", type: "Word32 -> Maybe Word64", description: "Get value of specified input by index" }
        ],
        "Transaction Outputs": [
            { name: "OutputScriptHash", type: "Word32 -> Maybe Word256", description: "Get script hash of specified output by index" },
            { name: "OutputValue", type: "Word32 -> Maybe Word64", description: "Get value of specified output by index" }
        ],
        "Time Locks": [
            { name: "CheckLockDistance", type: "Word16 -> ()", description: "Verify that input's sequence uses block distance and matches" },
            { name: "CheckLockDuration", type: "Word16 -> ()", description: "Verify that input's sequence uses time duration and matches" },
            { name: "CheckLockHeight", type: "Word32 -> ()", description: "Verify that input's locktime uses block height and matches" },
            { name: "CheckLockTime", type: "Word32 -> ()", description: "Verify that input's locktime uses block time and matches" },
            { name: "LockTime", type: "() -> Word32", description: "Get transaction lock time" },
            { name: "TxIsFinal", type: "() -> Bit", description: "Test if transaction is final (all inputs have max sequence)" },
            { name: "TxLockDistance", type: "() -> Word16", description: "Get transaction lock distance from sequence number" },
            { name: "TxLockDuration", type: "() -> Word16", description: "Get transaction lock duration from sequence number" },
            { name: "TxLockHeight", type: "() -> Word32", description: "Get transaction lock time as block height (if applicable)" },
            { name: "TxLockTime", type: "() -> Word32", description: "Get transaction lock time as Unix timestamp (if applicable)" }
        ],
        "Taproot": [
            { name: "CurrentAnnexHash", type: "() -> Maybe Word256", description: "Get annex hash of current input" },
            { name: "InternalKey", type: "() -> PubKey", description: "Get taproot internal public key" },
            { name: "ScriptCMR", type: "() -> Word256", description: "Get commitment Merkle root of current script" },
            { name: "TapleafVersion", type: "() -> Word8", description: "Get version byte of current taproot script leaf" },
            { name: "Tappath", type: "() -> Path", description: "Get taproot script path" }
        ],
        "Signatures": [
            { name: "CurrentScriptSigHash", type: "() -> Word256", description: "Get script signature hash for current input" },
            { name: "InputScriptSigHash", type: "Word32 -> Maybe Word256", description: "Get scriptSig hash of specified input by index" }
        ]
    }
};

